# 链表总结
常见链表分为
- 单链表
- 循环链表
- 双向链表

链表的特点：
- 由一个个节点 Node(data, next, prev) 组成。其中 next, prev 分别为指向下一个节点的指针，data 表示存储的数据。
- 链表是由一个个不连续的空间组成，由指针将零散的内存块串联在一起，因此比较节省空间(相较于 array)
- 链表适合于内存少，插入、删除频繁的使用场景。
- 链表不适用于查询频繁的使用场景
- 对于无序的链表，插入、删除操作时间复杂度为 `O(1)`。查找时间复杂度为 `O(n)`
- 对于有序的链表，插入、删除时间复杂度为 `O(n)`。查找时间复杂度为 `O(n)`
- 链表可以通过双向链表实现查询优化，记录上一次查询的位置，待下一次查询到来时，判断向前或者向后查找。

# 链表实现总结
- 理解指针，即指向某个变量的内存地址，通过指针引用即可找到相关变量
- 内存泄漏或者进行插入指针丢失
> 在进行插入或者删除操作时，避免指针丢失，或者循环指向的问题：例如:
> cur.next = node
> node.next = cur
> 以上由于 cur 的前一个指针出现自己指向自己，更多情况需要自己反复调试
- **使用哨兵优化**
> 对于整个链表来说，`self.head`表示头节点，也是存储整个链表的数据。在查询操作或者插入操作时，需要找到相关节点。
> 可以采用 `cur = self.head`。`cur = cur.next` 等来优化代码逻辑。
- **重点注意边缘条件**
> 对于操作链表来说，一般包含三种情况：1. 链表为空的情况。2. 链表只有一个节点的情况。3. 链表有多个节点的情况。
> 对于插入，删除来说。需要分情况讨论。避免 cur.next 或者 cur.prev 进行指向时出现 NoneType。需要灵活应对。

# 链表相关算法题
- 快慢指针判断回文字符串
  
- 快慢指针判断是否为环状链表
- 反转链表
- 有序链表的合并
- 删除指定位置的 Node